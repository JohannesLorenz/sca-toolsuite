0 Introduction
::::::::::::::

This file contains questions often asked by others.
Or questions I think others might ask.

CONTENTS

1 General
2 Compiling
3 Sandpiles

1 General
:::::::::

Q: Are there any other COPYING restrictions than GPL3?
A: None. This code was made by me in my free time, and I did not copy any line
   of code from other projects. This code was not written for any institution.

Q: I miss the ternary operator in the equation solver...
A: We have added it now. If you still miss it, please update your local
   version of the toolsuite.

Q: I need --help as a filename...
A: Try to pass ./--help to the program.

Q: Is there a project file for my code editor?
A: If you are using qt creator: Yes. Use src/sca-toolsuite.pro.

Q: Is Qt necessary?
A: No, the .pro file is only for people who use qt creator for coding. The
   Makefile generation is done by autotools.

2 Compiling
:::::::::::

Q: My compiler swaps a lot while compiling
A: T

Q: I get a lot of warnings about unused localc typedefs or maybe uninitialized
   variables. Why?
A: If this happens, your boost libraries are too old for your compiler. You'll
   find a line in our CMakeLists ("WARN_EXC") which you can enable to ignore
   the errors.

3 Sandpiles
:::::::::::

Q: How fast is the sandpile algorithm?
A: There are different experiments:
   
     * stabilize: stabilize one given (positive) configuration.
     * random throw: throw one grain at random position, then stabilize.
       Repeat it often enough. Runtime counted is started when a recurrent
       configuration is reached.

   For stabilize, we are faster if the grid contains a bit less than 3 grains
   on each cell. For random throw, we are much faster.

Q: How fast is the sandpile algorithm for the random throw?
A: There might be no faster currently, thought we don't know. We knew of the
   parallel and sequential stack algorithm by Sebastian Frehmel [4], ported to
   C++ by Johannes Lorenz. The sca algorithm works similar, but it is
   sequential. The reason for the speedup is that avalanches are developped in
   multiple levels, where in each level, each cell on the grid is assured to
   only fire once. This makes branch prediction and memory usage much easier.

   A comparison on an Intel (R) Core i7 (R) 2600 with 8MB L3 cache:

     sequential stack, C++ (2011):		1.17 s
     parallel stack, C++ (2011):		0.65 s (8 threads)
     our (sequential) algorithm (2012):		0.44 s

     We use gcc 4.8.1 and clang 3.3. For gcc, we used -O3 -flto, for clang -O3
     (-flto was not officially supported by our distribution).

   The first two algorithm are the stack algorithm by Sebastian Frehmel...
   The 3rd is the C++-Version by Johannes Lorenz
   The 4th one is the sca-toolsuite algorithm from Johannes Lorenz (April 2014),
   and the 5th one is his improved version from May 2014.

   For all algorithms, we used "Intel(R) Core(TM) i5-3570 CPU @ 3.40GHz" which has
   4 physical (one logical each) cores and 6 MB cache each. Note that only the first 2 algorithms were multi-core.
   Our RAM was 2x4 GB DDR3 (?) RAM.

   Setup:

    1)

    Machine: java -server -Xmx1024m -Xss4096k
    Threads: 4
    Algorithm: "Asynchronous (parallel) Fourstates, with cache line optimization."
    java -server -cp bin/ -Xmx1024m -Xss4096k parallel.asynchronous.fourstates.SandpileCA -h=1000 -w=1000 -nmt=2140000 -nt=4 -uco=true

    2)

    Machines: gcc -O3 -flto, clang -O3
    Threads:
    sh fourstates.sh -h=1000 -w=1000 -nmt=2140000 -nt=4 -uco=true

    3
    sh onestack.sh -h=1000 -w=1000 -nmt=2140000 -nt=1 -uco=true

     From 214.000 to 219.000, time for 10000 grains

     02/2010 11.78 s (java -server)
     10/2011 9.04 s (gcc)
     8.62
     03/2014 4.37 s (gcc) 4.72 s (clang)
     05/2014 3.15 s (clang), 3.28 s (gcc)

Q: What if we want to log avalanches in random throw?
A: Then we are even a lot faster, since n^2 avalanches can be thrown at once.

Q: Why is the sandpile algorithm so fast, even though it is sequential?
A: The reason for the speedup is that avalanches are developped in multiple
   levels, where in each level, each cell on the grid is assured to only fire
   once. Thus, we don't need to assure that a cell is not added multiple times
   to the stack of active cells. This makes branch prediction and memory usage
   much easier.

Q: Can our sequential sandpile algorithm be parallelized?
A: Maybe. We have not tested it yet.


